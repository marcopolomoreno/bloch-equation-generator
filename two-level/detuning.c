//Source code generated by the Bloch Equation Generator application:
//https://simufisica.com/en/tools/bloch-equation-generator/"
//Developer: Marco Polo Moreno de Souza"
//Contact: marcopolo@unir.br
//Creation date: 17/04/2025
//Version of the generator 1.4.1

//All units are in SI

#include <stdio.h>
#include <math.h>

int main() {
    FILE* file;
    file = fopen("data.txt", "w");


    double const Pi = 3.14159265358979;

    //Number of Bloch equations
    int const N = 4;


    //Density matrix
    double rho[N];


    //Adjustments to be made (type control + F to find what needs to be adjusted)
    //Adjustments 1 - Spectrum and temporal integration
    //Adjustments 2 - Rabi frequencies
    //Adjustments 3 - Decays
    //Adjustments 4 - Initial conditions
    //Adjustments 5 - Detunings
    



    //****************** Adjustments 1 - Spectrum and temporal integration ******************//
    //********************************************************************************//
    //Spectrum width, in MHz
    double const spectrumWidth = 200;
    
    //Detuning step, in MHz
    double const passo = 1;

    //Interaction time, in s
    double const tTotal = 1e-6;

    //Time integration step, in s
    double const h = 5e-12;
    



    //******************* Adjustments 2 - Rabi frequencies ***************************//
    //*******************************************************************************//
	//Real part of Rabi frequencies
	double const rabiFreq = 0.5*2*Pi*5e6;

	double A12 = rabiFreq;

	//Imaginary part of Rabi frequencies
	double B12 = 0;




    //************************ Adjustments 3 - Decays ******************************//
    //*******************************************************************************//
	//Decay rates of excited states
	double const decay = 2*Pi*5e6;

	double Gamma21 = decay/1.0;

	//Decay rates of coherences
	double gamma12 = 0.5*decay;
	//*******************************************************************************//



    
	//Detunings
	double delta21 = 0;




    //************************ Adjustments 4 - Initial conditions ***********************//
    //*******************************************************************************//
	//Initial populations
	double pop[N+1];
	pop[1] = 1.0/1.0;
	pop[2] = 0;

	//Initial coherences
	pop[3] = 0;
	pop[4] = 0;
	//*******************************************************************************//
    



    //Number of detuning points
    double D = spectrumWidth/(2*passo);

    //Tempo
    double t;
    
    //Number of time points
    double T = tTotal/h + 1;


    //Variables - data.txt file
	fprintf(file, "\\g(d)\\-(21)/2\\g(p) \\g(r)\\-(11) \\g(r)\\-(22) Re(\\g(s)\\-(12)) Im(\\g(s)\\-(12))\n");
	fprintf(file, "MHz    \n");




    //***************************** Bloch equations *********************************//
    //*********************************************************************************//
	double bloch(double a11, double a22, double a12, double b12, int j)
    {
		/*a11*/ if (j == 0) return - 2*a12*B12 + 2*b12*A12 + Gamma21*a22;
		/*a22*/ if (j == 1) return + 2*a12*B12 - 2*b12*A12 - Gamma21*a22;
		/*a12*/ if (j == 2) return -gamma12*a12 - delta21*b12 - B12*(a22 - a11);
		/*b12*/ if (j == 3) return -gamma12*b12 + delta21*a12 + A12*(a22 - a11);
    }
    //*********************************************************************************//


    int d, k, j;


    //Detuning loop
    for (d=-D; d<=D; d++)
    {
        t = 0;
        for (j=0; j<=N-1; j++)
            rho[j] = pop[j+1];
    

        //************************** Adjustments 5 - Detunings ***************************//
        //*******************************************************************************//
    
		delta21 = 2*Pi*passo*d*1e6;   //Field sweeping frequency

		//Two-photon coherences

		//Three-photon or more coherences: adjust if they exist

        //*******************************************************************//


        //Temporal loop
        for (k=0; k<=T; k++)
        {
			double k1[4], k2[4], k3[4], k4[4];

            //Step 1
			for (j=0; j<=N-1; j++)
			{
				k1[j] = bloch(rho[0], rho[1], rho[2], rho[3], j);
			}

            //Step 2
			for (j=0; j<=N-1; j++)
			{
				k2[j] = bloch(rho[0] + 0.5*h*k1[0], rho[1] + 0.5*h*k1[1], rho[2] + 0.5*h*k1[2], rho[3] + 0.5*h*k1[3], j);
			}

            //Step 3
			for (j=0; j<=N-1; j++)
			{
				k3[j] = bloch(rho[0] + 0.5*h*k2[0], rho[1] + 0.5*h*k2[1], rho[2] + 0.5*h*k2[2], rho[3] + 0.5*h*k2[3], j);
			}

            //Step 4
			for (j=0; j<=N-1; j++)
			{
				k4[j] = bloch(rho[0] + h*k3[0], rho[1] + h*k3[1], rho[2] + h*k3[2], rho[3] + h*k3[3], j);
			}

            //Update of the density matrix elements
            for (j=0; j<=N-1; j++)
            {
                rho[j] = rho[j] + h*(k1[j] + 2.0*k2[j] + 2.0*k3[j] + k4[j])/6.0;
            }

            t = t + h;
        }

        //Print the result on the screen
        printf("%.2f", passo*d);
        printf(" %g %g %g %g\n", rho[0], rho[1], rho[2], rho[3]);


        //Print the result in the data.txt file
        fprintf(file, "%.2f", passo*d);
        fprintf(file, " %g %g %g %g\n", rho[0], rho[1], rho[2], rho[3]);
    }

    fclose(file);

    return 0;
}
