//Source code generated by the Bloch Equation Generator application:
//https://simufisica.com/en/tools/bloch-equation-generator/
//Developer: Marco Polo Moreno de Souza
//Contact: marcopolo@unir.br
//Creation date: 17/04/2025
//Version of the generator 1.4.1

//All units are in SI
#include <stdio.h>
#include <math.h>

int main() {
    FILE* file;
    file = fopen("data.txt", "w");


    double const Pi = 3.14159265358979;

    //Number of Bloch equations
    int const N = 4;

    //Density matrix
    double rho[N];



    //Adjustments to be made (type control + F to find what needs to be adjusted)
    //Adjustments 1 - Rabi frequencies
    //Adjustments 2 - Decays
    //Adjustments 3 - Detunings
    //Adjustments 4 - Initial conditions
    //Adjustments 5 - Numerical integration parameters



    //******************* Adjustments 1 - Rabi frequencies ***************************//
    //*******************************************************************************//
	//Real part of Rabi frequencies
	double const freqRabi = 2*Pi*5e6;

	double A12 = freqRabi;

	//Imaginary part of Rabi frequencies
	double B12 = 0;



    
    //******************* Adjustments 2 - Decays ***************************//
    //***********************************************************************//
	//Decay rates of excited states
	double const decay = 2*Pi*5e6;

	double Gamma21 = decay/1.0;

	//Decay rates of coherences
	double gamma12 = 0.5*decay;

    
    
    
    //******************* Adjustments 3 - Detunings ***************************//
    //************************************************************************//
	//Detunings
	double delta21 = 0;

    


    //******************* Adjustments 4 - Initial conditions ***********************//
    //**************************************************************************//
	//Initial populations
	double pop[N+1];
	pop[1] = 1.0/1.0;
	pop[2] = 0;

	//Initial coherences
	pop[3] = 0;
	pop[4] = 0;




    //******************** Adjustments 5 - Numerical integration parameters ***********************//
    //*****************************************************************************************//
    //Integration time
    double const tTotal = 1e-6;

    //Time integration step
    double const h = 5e-12;

    //Interval between points in the graph, in units of h
    int const dt = 100;
    //*****************************************************************************************//
    //*****************************************************************************************//


    

    //Time ---
    double t;
    
    //Number of time points
    double T = tTotal/h + 1;


    //Variables - data.txt file
	fprintf(file, "t \\g(r)\\-(11) \\g(r)\\-(22) Re(\\g(s)\\-(12)) Im(\\g(s)\\-(12))\n");
	fprintf(file, "ns    \n");




    //************************** Bloch equations ***********************************//
    //********************************************************************************//
	double bloch(double a11, double a22, double a12, double b12, int j)
    {
		/*a11*/ if (j == 0) return - 2*a12*B12 + 2*b12*A12 + Gamma21*a22;
		/*a22*/ if (j == 1) return + 2*a12*B12 - 2*b12*A12 - Gamma21*a22;
		/*a12*/ if (j == 2) return -gamma12*a12 - delta21*b12 - B12*(a22 - a11);
		/*b12*/ if (j == 3) return -gamma12*b12 + delta21*a12 + A12*(a22 - a11);
    }
    //********************************************************************************//


    int k, j;


    
    for (j=0; j<=N-1; j++)
        rho[j] = pop[j+1];
        
    t = 0;

    //Temporal loop
    for (k=0; k<=T; k++)
    {
		double k1[4], k2[4], k3[4], k4[4];

		//Step 1
		for (j=0; j<=N-1; j++)
		{
			k1[j] = bloch(rho[0], rho[1], rho[2], rho[3], j);
		}

		//Step 2
		for (j=0; j<=N-1; j++)
		{
			k2[j] = bloch(rho[0] + 0.5*h*k1[0], rho[1] + 0.5*h*k1[1], rho[2] + 0.5*h*k1[2], rho[3] + 0.5*h*k1[3], j);
		}

		//Step 3
		for (j=0; j<=N-1; j++)
		{
			k3[j] = bloch(rho[0] + 0.5*h*k2[0], rho[1] + 0.5*h*k2[1], rho[2] + 0.5*h*k2[2], rho[3] + 0.5*h*k2[3], j);
		}

		//Step 4
		for (j=0; j<=N-1; j++)
		{
			k4[j] = bloch(rho[0] + h*k3[0], rho[1] + h*k3[1], rho[2] + h*k3[2], rho[3] + h*k3[3], j);
		}

        //Update of the density matrix elements
        for (j=0; j<=N-1; j++)
        {
            rho[j] = rho[j] + h*(k1[j] + 2*k2[j] + 2*k3[j] + k4[j])/6;
        }

        t = t + h;

        //Print the result on the screen
        if (k % dt == 0)
        {
            printf("%.2f", 1e9*t);
            printf(" %g %g %g %g\n", rho[0], rho[1], rho[2], rho[3]);
        }

        //Print the result in the data.txt file
        if (k % dt == 0)
        {
            fprintf(file, "%.2f", 1e9*t);
            fprintf(file, " %g %g %g %g\n", rho[0], rho[1], rho[2], rho[3]);
        }
    }

    fclose(file);

    return 0;
}
